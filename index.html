<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>AI Playground</title>

  <!-- External stylesheet -->
  <link rel="stylesheet" href="/style.css" />
</head>

<body>
  <h1>AI Playground</h1>
  <small>v0.4 – Conversational summarizer</small>

  <div class="controls">
    <label class="inline">
      <input type="checkbox" id="auto" checked />
      Auto-summarize on paste
    </label>

    <button id="debug-toggle" class="debug-toggle" aria-pressed="false" aria-controls="debug-panel" title="Toggle Token Inspector">Token Inspector</button>
  </div>
 
  <div class="buttons">
    <button data-mode="short" aria-pressed="false" onclick="selectPreset('short')">Short</button>
    <button data-mode="medium" aria-pressed="true" onclick="selectPreset('medium')">Medium</button>
    <button data-mode="detailed" aria-pressed="false" onclick="selectPreset('detailed')">Detailed</button>
    <button onclick="clearAll()" class="secondary">Clear</button>
    <button id="submit-btn" class="primary" onclick="handleSmartSubmit()" aria-label="Summarize current selection">Summarize</button>
  </div>

  <textarea id="input" placeholder="Paste text here..."></textarea>

  <div class="meta">
    <label>
      Max output chars:
      <input id="cap" type="number" value="900" min="200" max="5000" />
    </label>
    <span id="status"></span>
  </div>

  <section id="debug-panel" class="debug-panel" aria-expanded="false" aria-hidden="true" aria-label="Token Inspector Panel" style="display:none;">
    <div class="debug-header">
      <strong>Token Inspector</strong>
      <button id="debug-close" class="debug-close" aria-label="Close debug panel">Close</button>
    </div>
    <div class="debug-body">
      <div id="run-list" class="run-list" aria-live="polite"></div>
      <div id="run-inspector" class="run-inspector" hidden>
        <div class="inspector-tabs" role="tablist">
          <button role="tab" aria-selected="true" data-tab="prompt">Prompt</button>
          <button role="tab" aria-selected="false" data-tab="context">Context</button>
          <button role="tab" aria-selected="false" data-tab="request">Request</button>
          <button role="tab" aria-selected="false" data-tab="response">Response</button>
          <button role="tab" aria-selected="false" data-tab="logs">Logs</button>
        </div>
        <div id="inspector-content" class="inspector-content"></div>
      </div>
    </div>
  </section>

  <div class="output" id="output"></div>

  <script>
    const inputEl = document.getElementById("input");
    const outputEl = document.getElementById("output");
    const statusEl = document.getElementById("status");
    const capEl = document.getElementById("cap");
    const autoEl = document.getElementById("auto");
    const presetButtons = document.querySelectorAll('.buttons button[data-mode]');
    const submitBtn = document.getElementById("submit-btn");
 
    // Debug mode: persisted toggle & panel shell
    const DEBUG_KEY = 'ai_playground_debug';
    let debugEnabled = localStorage.getItem(DEBUG_KEY) === 'true';
    const debugToggleEl = () => document.getElementById('debug-toggle');
    const debugPanelEl = () => document.getElementById('debug-panel');
    const debugCloseEl = () => document.getElementById('debug-close');

    // DOM helpers for inspector
    const runListEl = () => document.getElementById('run-list');
    const runInspectorEl = () => document.getElementById('run-inspector');
    const inspectorContentEl = () => document.getElementById('inspector-content');

    let runs = [];

    // Storage abstraction layer - easily swappable for backend persistence later
    const SessionStorage = {
      SESSIONS_KEY: 'ai_playground_session',

      async save(sessionData) {
        // v0.4: localStorage implementation
        try {
          localStorage.setItem(this.SESSIONS_KEY, JSON.stringify(sessionData));
        } catch (e) {
          console.warn('Failed to save session:', e);
        }

        // v0.5+: backend implementation (just uncomment and add auth)
        // if (navigator.onLine && userToken) {
        //   await fetch('/api/sessions', {
        //     method: 'POST',
        //     headers: { 'Authorization': `Bearer ${userToken}` },
        //     body: JSON.stringify(sessionData)
        //   });
        // }
      },

      async load() {
        // v0.4: localStorage implementation
        try {
          const data = localStorage.getItem(this.SESSIONS_KEY);
          return data ? JSON.parse(data) : null;
        } catch (e) {
          console.warn('Failed to load session:', e);
          return null;
        }

        // v0.5+: backend implementation
        // if (navigator.onLine && userToken) {
        //   const res = await fetch('/api/sessions/current', {
        //     headers: { 'Authorization': `Bearer ${userToken}` }
        //   });
        //   return res.ok ? await res.json() : null;
        // }
      },

      async clear() {
        try {
          localStorage.removeItem(this.SESSIONS_KEY);
        } catch (e) {
          console.warn('Failed to clear session:', e);
        }
      }
    };

    // Session management
    async function saveSession() {
      const sessionData = {
        runs: runs,
        lastModified: new Date().toISOString()
      };
      await SessionStorage.save(sessionData);
    }

    async function loadSession() {
      const sessionData = await SessionStorage.load();
      if (sessionData && sessionData.runs) {
        runs = sessionData.runs;
        renderDebugPanel();
        updateSmartButton();
      }
    }

    // Create a lightweight run record and render
    function createRunRecord(mode, payload) {
      const id = Date.now().toString(36) + '-' + Math.random().toString(36).slice(2,8);
      const run = {
        id,
        timestamp: new Date().toISOString(),
        ui: { mode, cap: Number(capEl.value || 900), auto: autoEl.checked, debug: debugEnabled },
        prompt: {
          system: null, // Will be populated from backend response
          instruction: presetInstruction(mode, Number(capEl.value || 900)),
          content: payload.slice(0,2000),
          composed: payload,
          actualUserPrompt: null // Will be populated from backend response
        },
        request: { url: '/api/summarize', bodySize: payload.length, headers: { 'Content-Type': 'application/json' } },
        response: null,
        status: 'pending',
        durationMs: null,
        logs: ['Compose prompt']
      };
      runs.unshift(run);
      if (runs.length > 50) runs.pop();
      renderDebugPanel();
      saveSession(); // Auto-save on new run
      return id;
    }

    function finalizeRunRecord(id, details = {}) {
      const run = runs.find(r => r.id === id);
      if (!run) return;
      run.status = details.status || (details.error ? 'error' : 'ok');
      run.response = { snippet: details.response && details.response.summary ? details.response.summary : (details.response || null), raw: details.raw || null };
      run.durationMs = details.durationMs || null;

      // Update prompts with actual values from backend if available
      if (details.response) {
        if (details.response.systemPrompt) {
          run.prompt.system = details.response.systemPrompt;
        }
        if (details.response.userPrompt) {
          run.prompt.actualUserPrompt = details.response.userPrompt;
        }
      }

      if (details.error) run.logs.push('Error: ' + details.error);
      else run.logs.push('Response received');
      renderDebugPanel();
      saveSession(); // Auto-save when run completes
    }

    function escapeHtml(s) { return String(s || '').replace(/[&<>\"]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;'}[c])); }

    let currentRunId = null;

    function switchInspectorTab(tabName) {
      const tabButtons = document.querySelectorAll('.inspector-tabs button[role="tab"]');
      const tabPanels = document.querySelectorAll('.inspector-content .tab-panel');

      tabButtons.forEach(btn => {
        const isActive = btn.dataset.tab === tabName;
        btn.setAttribute('aria-selected', isActive ? 'true' : 'false');
      });

      tabPanels.forEach(panel => {
        const isActive = panel.dataset.tab === tabName;
        panel.setAttribute('aria-hidden', isActive ? 'false' : 'true');
      });
    }

    function openRunInspector(runId) {
      const r = runs.find(x => x.id === runId);
      const inspector = runInspectorEl();
      const content = inspectorContentEl();
      if (!r || !inspector || !content) return;

      currentRunId = runId;
      inspector.hidden = false;

      const payloadPreview = (r.prompt.composed || '').slice(0,1000);
      const fullPayload = escapeHtml(r.prompt.composed || '');

      // Build tab panels
      content.innerHTML = `
        <div class="tab-panel" data-tab="prompt" aria-hidden="false">
          <h4>System Prompt (from backend)</h4>
          <pre>${escapeHtml(r.prompt.system || 'Pending...')}</pre>
          <h4>Frontend Instruction (generated)</h4>
          <pre>${escapeHtml(r.prompt.instruction)}</pre>
          <h4>Actual User Prompt (sent to AI)</h4>
          <pre>${escapeHtml(r.prompt.actualUserPrompt || 'Pending...')}</pre>
        </div>
        <div class="tab-panel" data-tab="context" aria-hidden="true">
          <h4>Full Content Sent</h4>
          <pre>${fullPayload}</pre>
        </div>
        <div class="tab-panel" data-tab="request" aria-hidden="true">
          <h4>Request Details</h4>
          <pre>Endpoint: ${escapeHtml(r.request.url)}
Body size: ${r.request.bodySize} chars
Headers: ${escapeHtml(JSON.stringify(r.request.headers, null, 2))}
${r.response && r.response.raw && r.response.raw.conversationLength ? `Conversation length: ${r.response.raw.conversationLength} messages\n` : ''}
UI State:
  Mode: ${escapeHtml(r.ui.mode)}
  Cap: ${r.ui.cap}
  Auto: ${r.ui.auto}
  Debug: ${r.ui.debug}</pre>
        </div>
        <div class="tab-panel" data-tab="response" aria-hidden="true">
          <h4>Response Summary</h4>
          <pre>${escapeHtml(r.response && r.response.snippet ? r.response.snippet : 'No response yet')}</pre>
          ${r.response && r.response.raw ? `<h4>Raw Response</h4><pre>${escapeHtml(JSON.stringify(r.response.raw, null, 2))}</pre>` : ''}
        </div>
        <div class="tab-panel" data-tab="logs" aria-hidden="true">
          <h4>Execution Log</h4>
          <pre>Timestamp: ${r.timestamp}
Status: ${r.status}
Duration: ${r.durationMs ? r.durationMs + ' ms' : 'N/A'}

Log entries:
${escapeHtml(r.logs.map((log, i) => `${i + 1}. ${log}`).join('\n'))}</pre>
        </div>
      `;

      // Attach tab click handlers
      const tabButtons = inspector.querySelectorAll('.inspector-tabs button[role="tab"]');
      tabButtons.forEach(btn => {
        btn.addEventListener('click', () => switchInspectorTab(btn.dataset.tab));
      });

      // Set initial tab to prompt
      switchInspectorTab('prompt');
    }

    function renderDebugPanel() {
      const panel = debugPanelEl();
      if (!panel) return;
      const list = runListEl();
      if (list) {
        if (runs.length === 0) {
          list.innerHTML = '<div class="run-empty">No runs yet.</div>';
        } else {
          list.innerHTML = runs.map(r => `
            <div class="run-entry" data-run-id="${r.id}" role="button" tabindex="0">
              <div class="run-meta"><strong>${r.ui.mode}</strong> • ${new Date(r.timestamp).toLocaleTimeString ? new Date(r.timestamp).toLocaleTimeString() : r.timestamp} • ${r.status}</div>
              <div class="run-snippet">${escapeHtml(r.prompt.content.slice(0,200))}${r.prompt.content.length>200 ? '…' : ''}</div>
            </div>
          `).join('');
          list.querySelectorAll('.run-entry').forEach(el => {
            el.addEventListener('click', () => openRunInspector(el.dataset.runId));
            el.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') openRunInspector(el.dataset.runId); });
          });
        }
      }
    }

    function applyDebugUIState() {
      const btn = debugToggleEl();
      const panel = debugPanelEl();
      const closeBtn = debugCloseEl();
      if (!btn || !panel) return;
      btn.setAttribute('aria-pressed', debugEnabled ? 'true' : 'false');
      panel.setAttribute('aria-expanded', debugEnabled ? 'true' : 'false');

      // Opening: ensure panel is discoverable and focus moves into it
      if (debugEnabled) {
        // Remove inert (if present) so assistive tech can reach it
        panel.removeAttribute('inert');
        try { panel.inert = false; } catch (e) {}

        panel.setAttribute('aria-hidden', 'false');
        panel.style.display = 'block';

        // Automatically open the most recent run if available
        if (runs.length > 0 && !currentRunId) {
          openRunInspector(runs[0].id);
        }

        // Move keyboard focus into the panel for keyboard users
        if (closeBtn && typeof closeBtn.focus === 'function') {
          closeBtn.focus();
        }

        document.body.classList.add('debug-open');
        return;
      }

      // Closing: if focus is inside the panel, move it to the toggle so it isn't hidden from AT
      if (panel.contains(document.activeElement) && typeof btn.focus === 'function') {
        btn.focus();
      }

      panel.setAttribute('aria-hidden', 'true');
      panel.style.display = 'none';

      // Mark inert to prevent the panel from being reachable by assistive tech or focus
      panel.setAttribute('inert', '');
      try { panel.inert = true; } catch (e) {}

      document.body.classList.remove('debug-open');
    }

    function toggleDebug() {
      debugEnabled = !debugEnabled;
      localStorage.setItem(DEBUG_KEY, debugEnabled ? 'true' : 'false');
      applyDebugUIState();
    }

    if (debugToggleEl()) debugToggleEl().addEventListener('click', toggleDebug);
    if (debugCloseEl()) debugCloseEl().addEventListener('click', () => { debugEnabled = false; localStorage.setItem(DEBUG_KEY, 'false'); applyDebugUIState(); });

    applyDebugUIState();

    // Load session on page load
    loadSession();

    // Initialize smart button state
    updateSmartButton();

    let pasteTimer = null;
 
    inputEl.addEventListener("paste", () => {
      if (!autoEl.checked) return;
      clearTimeout(pasteTimer);
      pasteTimer = setTimeout(() => {
        let active = document.querySelector('.buttons button[data-mode][aria-pressed="true"]');
        if (!active) { selectPreset('medium'); active = document.querySelector('.buttons button[data-mode][aria-pressed="true"]'); }
        runPreset(active?.dataset.mode || 'medium');
      }, 250);
    });
 
    // ensure a default preset is set (fallback to medium)
    if (!document.querySelector('.buttons button[data-mode][aria-pressed="true"]')) {
      const fallback = document.querySelector('.buttons button[data-mode="medium"]');
      fallback && fallback.setAttribute('aria-pressed', 'true');
    }

    function handleSmartSubmit() {
      // Route to appropriate handler based on conversation state
      const hasSuccessfulRun = runs.some(r => r.status === 'ok' && r.response && r.response.snippet);
      if (hasSuccessfulRun) {
        continueConversation();
      } else {
        submitPreset();
      }
    }

    function clearAll() {
      inputEl.value = "";
      outputEl.innerText = "";
      statusEl.innerText = "";
      presetButtons.forEach(b => b.setAttribute('aria-pressed', 'false'));
      updateSmartButton();
    }

    function updateSmartButton() {
      // Adapt button text and behavior based on conversation state
      const hasSuccessfulRun = runs.some(r => r.status === 'ok' && r.response && r.response.snippet);
      if (submitBtn) {
        if (hasSuccessfulRun) {
          submitBtn.textContent = "Continue";
          submitBtn.setAttribute('aria-label', 'Continue conversation with context');
          submitBtn.setAttribute('title', 'Continue with previous summary as context');
        } else {
          submitBtn.textContent = "Summarize";
          submitBtn.setAttribute('aria-label', 'Summarize current selection');
          submitBtn.setAttribute('title', '');
        }
      }
    }

    function buildConversationMessages(mode, text, cap) {
      const systemPrompt = "You are a browser-embedded AI assistant. Summarize accurately and concisely. Prefer bullet points. If info is missing, say so.";
      const instruction = presetInstruction(mode, cap);
      const userMessage = `INSTRUCTION:\n${instruction}\n\nCONTENT:\n${text}`;

      // Get successful runs for conversation context
      const successfulRuns = runs.filter(r => r.status === 'ok' && r.response && r.response.snippet);

      const messages = [{ role: "system", content: systemPrompt }];

      // Add previous conversation turns (up to last 3 for context window management)
      const recentRuns = successfulRuns.slice(0, 3).reverse();
      recentRuns.forEach(run => {
        if (run.prompt.actualUserPrompt) {
          messages.push({ role: "user", content: run.prompt.actualUserPrompt });
        }
        if (run.response.snippet) {
          messages.push({ role: "assistant", content: run.response.snippet });
        }
      });

      // Add current user message
      messages.push({ role: "user", content: userMessage });

      return messages;
    }

    async function continueConversation() {
      const text = inputEl.value || "";
      const cap = Math.max(200, Math.min(5000, Number(capEl.value || 900)));

      if (!text.trim()) {
        outputEl.innerText = "Paste some text first.";
        return;
      }

      const lastRun = runs.find(r => r.status === 'ok' && r.response && r.response.snippet);
      if (!lastRun) {
        outputEl.innerText = "No previous summary to continue from.";
        return;
      }

      // Use "medium" mode for continue, or current selected mode
      let active = document.querySelector('.buttons button[data-mode][aria-pressed="true"]');
      const mode = active?.dataset.mode || 'medium';

      const messages = buildConversationMessages(mode, text, cap);

      // Create run record (use special payload for conversation)
      const payload = `[Conversation mode - ${messages.length} messages]\n${text}`;
      const runId = createRunRecord(mode, payload);

      statusEl.innerText = "Continuing conversation...";
      outputEl.innerText = "";

      const start = performance.now();

      try {
        const resp = await fetch("/api/summarize", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ messages: messages })
        });

        const data = await resp.json();
        const ms = Math.round(performance.now() - start);

        if (!resp.ok) {
          if (runId) finalizeRunRecord(runId, { status: 'error', httpStatus: resp.status, error: data?.error || `Request failed (${resp.status})`, durationMs: ms });
          throw new Error(data?.error || `Request failed (${resp.status})`);
        }

        let out = (data.summary || "").trim();
        if (out.length > cap) {
          out = out.slice(0, cap - 1) + "…";
          if (runId) finalizeRunRecord(runId, { status: 'ok', httpStatus: resp.status, response: data, raw: data, truncated: true, durationMs: ms });
        } else {
          if (runId) finalizeRunRecord(runId, { status: 'ok', httpStatus: resp.status, response: data, raw: data, durationMs: ms });
        }

        outputEl.innerText = out;
        statusEl.innerText = `Done (${ms} ms) • Mode: ${mode} • Conversation`;
        updateSmartButton();
      } catch (err) {
        const ms = Math.round(performance.now() - start);
        if (runId) finalizeRunRecord(runId, { status: 'error', error: err.message || String(err), durationMs: ms });
        statusEl.innerText = `Error (${ms} ms)`;
        outputEl.innerText = `Error: ${err.message || err}`;
        updateSmartButton();
      }
    }

    function presetInstruction(mode, cap) {
      if (mode === "short") {
        return `Summarize in 5 bullets. Each bullet under 12 words. Total output under ${cap} characters.`;
      }
      if (mode === "medium") {
        return `Summarize in 8 bullets with 1 short takeaway line at the end. Total output under ${cap} characters.`;
      }
      return `Provide: (1) 10-bullet summary, (2) key definitions, (3) 3 suggested next actions. Total output under ${cap} characters.`;
    }

    async function runPreset(mode) {
      const text = inputEl.value || "";
      const cap = Math.max(200, Math.min(5000, Number(capEl.value || 900)));

      if (!text.trim()) {
        outputEl.innerText = "Paste some text first.";
        return;
      }

      const instruction = presetInstruction(mode, cap);
      const payload = `INSTRUCTION:\n${instruction}\n\nCONTENT:\n${text}`;

      // create a run record for the inspector
      const runId = (typeof createRunRecord === 'function') ? createRunRecord(mode, payload) : null;

      statusEl.innerText = "Summarizing...";
      outputEl.innerText = "";

      const start = performance.now();

      try {
        const resp = await fetch("/api/summarize", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ text: payload })
        });

        const data = await resp.json();
        const ms = Math.round(performance.now() - start);

        if (!resp.ok) {
          if (runId) finalizeRunRecord(runId, { status: 'error', httpStatus: resp.status, error: data?.error || `Request failed (${resp.status})`, durationMs: ms });
          throw new Error(data?.error || `Request failed (${resp.status})`);
        }

        let out = (data.summary || "").trim();
        if (out.length > cap) {
          out = out.slice(0, cap - 1) + "…";
          if (runId) finalizeRunRecord(runId, { status: 'ok', httpStatus: resp.status, response: data, raw: data, truncated: true, durationMs: ms });
        } else {
          if (runId) finalizeRunRecord(runId, { status: 'ok', httpStatus: resp.status, response: data, raw: data, durationMs: ms });
        }

        outputEl.innerText = out;
        statusEl.innerText = `Done (${ms} ms) • Mode: ${mode}`;
        updateSmartButton();
      } catch (err) {
        const ms = Math.round(performance.now() - start);
        if (runId) finalizeRunRecord(runId, { status: 'error', error: err.message || String(err), durationMs: ms });
        statusEl.innerText = `Error (${ms} ms)`;
        outputEl.innerText = `Error: ${err.message || err}`;
        updateSmartButton();
      }
    }

    function selectPreset(mode) {
      // update pressed state only (do not auto-run)
      presetButtons.forEach(b => b.setAttribute('aria-pressed', b.dataset.mode === mode ? 'true' : 'false'));
    }

    function submitPreset() {
      let active = document.querySelector('.buttons button[data-mode][aria-pressed="true"]');
      if (!active) {
        selectPreset('medium');
        active = document.querySelector('.buttons button[data-mode][aria-pressed="true"]');
      }
      const mode = active?.dataset.mode || 'medium';
      runPreset(mode);
    }
  </script>
</body>
</html>
